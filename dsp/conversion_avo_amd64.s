// Code generated by command: go run conversion_avo_amd64.go -out conversion_avo_amd64.s -stubs stub_windows.go. DO NOT EDIT.

#include "textflag.h"

// func Ui8tof32(input []byte, output []float32)
// Requires: SSE, SSE2, SSE4.1
TEXT ·Ui8tof32(SB), NOSPLIT, $0-48
	MOVQ input_base+0(FP), AX
	MOVQ input_len+8(FP), CX
	MOVQ output_base+24(FP), DX
	MOVQ output_len+32(FP), BX

	// Pick shortest length
	CMPQ BX, CX
	JGE  ui8tof32_min_len
	MOVQ BX, CX

ui8tof32_min_len:
	MOVQ $0x0000000000000000, BX

	// If input is too short to optimize (less than 32 bytes) then single step
	MOVQ $0x0000000000000020, SI
	CMPQ SI, CX
	JGE  ui8tof32_stepper

	// Align output to 16-byte boundary
	MOVQ DX, SI
	ANDQ $0x0f, SI
	SHRQ $0x02, SI
	JZ   ui8tof32_aligned
	MOVQ $0x0000000000000004, DI
	SUBQ SI, DI

ui8tof32_align:
	MOVBQZX  (AX), SI
	INCQ     AX
	SUBQ     $0x80, SI
	CVTSQ2SS SI, X0
	MOVSS    X0, (DX)
	ADDQ     $0x04, DX
	INCQ     BX
	CMPQ     BX, DI
	JLT      ui8tof32_align

ui8tof32_aligned:
	MOVQ   CX, SI
	ANDQ   $0xfffffff0, SI
	CMPQ   BX, SI
	JGE    ui8tof32_stepper
	CMPB   ·useSSE4+0(SB), $0x01
	JNE    ui8tof32_nosse4
	MOVL   $0x80808080, DI
	MOVD   DI, X3
	PSHUFL $0x00, X3, X3

ui8tof32_sse4_loop:
	// Load 16 unsigned 8-bit values
	MOVOU (AX), X0

	// Make the values signed
	PSUBB X3, X0

	// Lowest 4 values (bytes 0-3)
	PMOVSXBD X0, X2

	// Convert 32-bit signed integers to 32-bit float
	CVTPL2PS X2, X2
	MOVAPS   X2, (DX)

	// Next 4 values (bytes 4-7)
	PSHUFL   $0x01, X0, X2
	PMOVSXBD X2, X2

	// Convert 32-bit signed integers to 32-bit float
	CVTPL2PS X2, X2
	MOVAPS   X2, 16(DX)

	// Next 4 values (bytes 8-11)
	PSHUFL   $0x02, X0, X2
	PMOVSXBD X2, X2

	// Convert 32-bit signed integers to 32-bit float
	CVTPL2PS X2, X2
	MOVAPS   X2, 32(DX)

	// Next 4 values (bytes 12-15)
	PSHUFL   $0x03, X0, X2
	PMOVSXBD X2, X2

	// Convert 32-bit signed integers to 32-bit float
	CVTPL2PS X2, X2
	MOVAPS   X2, 48(DX)
	ADDQ     $0x10, BX
	ADDQ     $0x10, AX
	ADDQ     $0x40, DX
	CMPQ     BX, SI
	JLT      ui8tof32_sse4_loop
	JMP      ui8tof32_stepper

ui8tof32_nosse4:
	MOVL   $0x80808080, DI
	MOVD   DI, X4
	PSHUFL $0x00, X4, X4

ui8tof32_sse2_loop:
	// Load 16 unsigned 8-bit values
	MOVOU (AX), X0

	// Make the values signed
	PSUBB X4, X0
	MOVO  X0, X2

	// Lowest 4 values (bytes 0-3)
	PUNPCKLBW X2, X2
	MOVO      X2, X3
	PUNPCKLWL X2, X2
	PSRAL     $0x18, X2
	CVTPL2PS  X2, X2
	MOVAPS    X2, (DX)

	// Next 4 values (bytes 4-7)
	PUNPCKHWL X3, X3
	PSRAL     $0x18, X3
	CVTPL2PS  X3, X3
	MOVAPS    X3, 16(DX)

	// Next 4 values (bytes 8-11)
	PUNPCKHBW X0, X0
	MOVO      X0, X3
	PUNPCKLWL X0, X0
	PSRAL     $0x18, X0
	CVTPL2PS  X0, X0
	MOVAPS    X0, 32(DX)

	// Next 4 values (bytes 12-15)
	PUNPCKHWL X3, X3
	PSRAL     $0x18, X3
	CVTPL2PS  X3, X3
	MOVAPS    X3, 48(DX)
	ADDQ      $0x10, BX
	ADDQ      $0x10, AX
	ADDQ      $0x40, DX
	CMPQ      BX, SI
	JLT       ui8tof32_sse2_loop

	// TODO: work increasingly smaller blocks
ui8tof32_stepper:
	CMPQ BX, CX
	JGE  ui8tof32_done

ui8tof32_step:
	MOVBQZX  (AX), SI
	INCQ     AX
	SUBQ     $0x80, SI
	CVTSQ2SS SI, X1
	MOVSS    X1, (DX)
	ADDQ     $0x04, DX
	INCQ     BX
	CMPQ     BX, CX
	JLT      ui8tof32_step

ui8tof32_done:
	RET
